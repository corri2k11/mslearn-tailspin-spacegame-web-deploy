#This configuration resembles the one that you built in the 
#POC (Proof of concept) on the previous module.

trigger:
- '*'

variables:
  buildConfiguration: 'Release'
  releaseBranchName: 'release'

#Define Schedules section with cron expression. 
#You can define more than one expresion.
#It triggers the pipeline to run against  the release branch (taking code from github release branch, building and deploying all the way to QA every day at 3AM.)
#always: flag set to FALSE, means pipeline always runs BUT ONLY when release branch has changes (different than prior run), otherwise pipeline wont run!
schedules:
  - cron: '0 3 * * *'
    displayName: 'Deploy to QA everyday at 3 AM'
    branches:
      include:
      - release
    always: false

stages:
- stage: 'Build'
  displayName: 'Build Web application'
  jobs: 
  - job: 'Build'
    displayName: 'Build job'
    pool:
      vmImage: 'ubuntu-16.04'
      demands:
        - npm

    variables:
      wwwrootDir: 'Tailspin.SpaceGame.Web/wwwroot'
      dotnetSdkVersion: '3.1.100'

    steps:
    - task: UseDotNet@2
      displayName: 'Use .NET Core SDK $(dotnetSdkVersion)'
      inputs:
        version: '$(dotnetSdkVersion)'

    - task: Npm@1
      displayName: 'Run npm install'
      inputs:
        verbose: false

    - script: './node_modules/.bin/node-sass $(wwwrootDir) --output $(wwwrootDir)'
      displayName: 'Compile Sass assets'

    - task: gulp@1
      displayName: 'Run gulp tasks'

    - script: 'echo "$(Build.DefinitionName), $(Build.BuildId), $(Build.BuildNumber)" > buildinfo.txt'
      displayName: 'Write build info'
      workingDirectory: $(wwwrootDir)

    - task: DotNetCoreCLI@2
      displayName: 'Restore project dependencies'
      inputs:
        command: 'restore'
        projects: '**/*.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'Build the project - $(buildConfiguration)'
      inputs:
        command: 'build'
        arguments: '--no-restore --configuration $(buildConfiguration)'
        projects: '**/*.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'Publish the project - $(buildConfiguration)'
      inputs:
        command: 'publish'
        projects: '**/*.csproj'
        publishWebProjects: false
        arguments: '--no-build --configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/$(buildConfiguration)'
        zipAfterPublish: true

    - publish: '$(Build.ArtifactStagingDirectory)'
      artifact: drop

- stage: 'DEV'
  displayName: 'Deploy to DEV'
  dependsOn: Build   
  condition: |   #condition that directs the system to run the stage only when previous stage succeds and the current branch is release. This ensures that relase features are deployed ONLY to DEV env.
    and
    (
      succeeded(),
      eq(variables['Build.SourceBranchName'], variables['releaseBranchName'])
    )
  jobs:
  - deployment: Deploy  #especial job "deployment"
    pool:
      vmImage: 'ubuntu-16.04'
    environment: dev
    variables:
    - group: Release
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: drop
          - task: AzureWebApp@1
            displayName: 'Azure App Service DEV Deployment'
            inputs:
              azureSubscription: 'azAppServiceCon'  #service connection name
              appName: '$(AzWebAppNameDev)'         #uses WebAppNameDev to deploy to mapped Azure App Service instance associated to DEV env.
              package: '$(Pipeline.Workspace)/drop/$(buildConfiguration)/*.zip'

#condition: runs the stage only when the build reason equals Schedule
#if condition is false, stage is skipped, but the prior stages (like build) continue to run.
#for learning purpose, condition is commmented out to enable change be deployed from DEV to QA 
#w/out having to wait for schedule to be triggered at 3 AM!  just let it flow...
#by default, if no condition is set, it will run the stage!
- stage: 'QA'
  displayName: 'Deploy to QA'
  dependsOn: DEV
  #condition: eq(variables['Build.Reason'],'Schedule')
  jobs:
  - deployment: Deploy
    pool:
      vmImage: 'ubuntu-16.04'
    environment: QA
    variables:
    - group: 'Release'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: drop
          - task: AzureWebApp@1
            displayName: 'Azure App Service QA Deployment'
            inputs:
              azureSubscription: 'azAppServiceCon'  #service connection name
              appName: '$(AzWebAppNameQA)'          #uses WebAppNameQA to deploy to mapped Azure App Service instance associated to QA env.
              package: '$(Pipeline.Workspace)/drop/$(buildConfiguration)/*.zip'
